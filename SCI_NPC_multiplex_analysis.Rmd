---
title: "Neural Progenitor Cells for Treatment of Spinal Cord Injury"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r echo=FALSE, warning=FALSE, error=FALSE, message=FALSE}
#1. INSTALLING PACKAGES
#install.packages("ggplot2")
#install.packages("data.table")
#install.packages("RColorBrewer")
#install.packages("cowplot")
#install.packages("gridExtra")
#install.packages("gplots")

#2. ATTACHING PACKAGES
library(ggplot2)
library(data.table)
library(RColorBrewer)
library(cowplot)
library(knitr)
library(gridExtra)
library(grid)
library(gplots)

rm(list=ls())
```

```{r echo=FALSE, warning=FALSE, error=FALSE, message=FALSE}
#1. IMPORTING DATA
DT = fread("SCI_NPC_saline_overtime_data.csv")

#2. CLEANING COLUMN NAMES
column_name_adjuster <- function(column_name_raw){
    column_name_adjusted <- substr(column_name_raw, 4, nchar(column_name_raw))
    column_name_adjusted <- substr(column_name_adjusted, 0, nchar(column_name_adjusted)-5)
    return(column_name_adjusted)
}

col_name_subset <- names(DT[,!c("SCI", "treatment", "evaluation", "evaluation_weeks")])   
col_name_subset <- unlist(lapply(col_name_subset, function(col_name){column_name_adjuster(col_name)}))
names(DT) <-  c("SCI", "treatment", "evaluation", "evaluation_weeks", col_name_subset)

#3. REMOVING UNNECESSARY DATA
DT <-  DT[!is.na(evaluation_weeks)]
DT[, "evaluation"] = NULL

#4. FROM WIDE TO LONG FORMAT
DT_melt <- melt.data.table(DT, id.vars=c("SCI", "treatment", "evaluation_weeks"))

#5. NORMALIZE EXPRESSION TO HEALTHY FOR EACH TARGET SEPARATELY
expression_normalizer <-  function(list_object){
  divisor <-  list_object[treatment=="none", mean(value)]
  list_object[,value:=ifelse(value==0,1,value)]
  #Function normalizes the expression data to the mean of healthy animals. norm_value = over/under expression in %
  normalizer <- function(one_value){
      if(one_value>0 & divisor>0){return(one_value/divisor)}
      if(one_value>0 & divisor<0){return((one_value-divisor)/(-1*divisor))}
      if(one_value<0 & divisor>0){return(1/((divisor-one_value)/divisor))}
      if(one_value<0 & divisor<0){return(1/(one_value/divisor))}
  }
  
  norm_value_col <- data.table(do.call(rbind, lapply(list_object[, value], function(val){normalizer(val)})))
  list_object[, "norm_value"] <- log2(norm_value_col)
  return(list_object)
}

DT_melt <- do.call(rbind, lapply(split(DT_melt, DT_melt[,variable]), function(object){expression_normalizer(object)}))

#6. REMOVING UNNECESSARY DATA & ADJUSTING VARIABLE TYPES
DT_melt[, "SCI"] = NULL
DT_melt <- DT_melt[treatment!="none"]
DT_melt[, "treatment"] <- factor(DT_melt[, treatment])

```

```{r echo=FALSE, warning=FALSE, error=FALSE, message=FALSE}
################################################################### STATISTICAL ANALYSIS ##############################################################
```

```{r echo=FALSE, warning=FALSE, error=FALSE, message=FALSE}
#1. Summarizing data per treatment, time point and target
DT_summary <- DT_melt[, .(norm_value = mean(norm_value), norm_value_sd = sd(norm_value), n=.N), by=c("treatment", "evaluation_weeks", "variable")]
DT_summary <- DT_summary[,`:=`(SEMx1.96=qnorm(0.975)*norm_value_sd/sqrt(n))][, `:=`(CI.lower = norm_value-SEMx1.96, CI.upper=norm_value+SEMx1.96)]

```

```{r echo=FALSE, warning=FALSE, error=FALSE, message=FALSE}
#1. Evaluating assumption of normal distribution
norm_function <- function(list_object){
  if(nrow(list_object)<3){
    return(list_object[,p_value:=0])
  } else {
    return(list_object[,p_value:=shapiro.test(list_object[, norm_value])[2]])
  }
}
norm_test_p <- do.call(rbind, lapply(split(DT_melt, DT_melt[, .(treatment, evaluation_weeks, variable)]), function(subset){norm_function(subset)}))
norm_test_p <- norm_test_p[, .(p_value= mean(p_value)), by=c("treatment", "evaluation_weeks", "variable")]

#2. Evaluating assumption of homogenity of variances between treatments within time points
homo_function <- function(list_object){
  if(nrow(list_object)<3){
    return(list_object[,p_value:=0])
  } else {
    return(list_object[,p_value:=fligner.test(list_object$norm_value, list_object$treatment)[3]])
  }
}
homo_test_p <- do.call(rbind, lapply(split(DT_melt, DT_melt[, .(evaluation_weeks, variable)]), function(subset){homo_function(subset)}))
homo_test_p <- homo_test_p[, .(p_value=mean(p_value)), by=c("evaluation_weeks", "variable")]

#3. Independent two group comparison 
setkey(homo_test_p, "evaluation_weeks", "variable")
setkey(norm_test_p, "evaluation_weeks", "variable", "treatment")

two_group_test <- function(list_object, norm_values, homo_values){
  week = list_object[, evaluation_weeks][1]
  target = list_object[, variable][1]
  
  norm_assump_1 = FALSE
  norm_assump_2 = FALSE
  homo_assump = FALSE
  #Checking for fulfillment of assumptions
  if(homo_values[.(week, target), p_value]>0.05){
    homo_assump = TRUE
  }
  
  if(norm_values[.(week, target, "NPC"), p_value]>0.05){
    norm_assump_1 = TRUE
  }
  
  if(norm_values[.(week, target, "saline"), p_value]>0.05){
    norm_assump_2 = TRUE
  }
  
  if(isTRUE(norm_assump_1) & isTRUE(norm_assump_2)){
    if(isTRUE(homo_assump)){
      p_value_out <- t.test(list_object[treatment=="saline", norm_value], list_object[treatment=="NPC", norm_value], var.equal = TRUE)$p.value
      return(data.table(evaluation_week=week, variable=target, p_value=p_value_out, test="t.test_equal_var"))
    } else {
      p_value_out <- t.test(list_object[treatment=="saline", norm_value], list_object[treatment=="NPC", norm_value], var.equal = FALSE)$p.value
      return(data.table(evaluation_week=week, variable=target, p_value=p_value_out, test="t.test_unequal_var"))
    }
  } else {
    p_value_out <- wilcox.test(list_object[treatment=="saline", norm_value], list_object[treatment=="NPC", norm_value])$p.value
    return(data.table(evaluation_week=week, variable=target, p_value = p_value_out, test="wilcox_test"))
  }
}

group_comparison_p <- do.call(rbind, lapply(split(DT_melt, DT_melt[, .(variable, evaluation_weeks)]), function(subset){two_group_test(subset, norm_test_p, homo_test_p)}))

```

```{r echo=FALSE, warning=FALSE, error=FALSE, message=FALSE}
#ANALYSIS OF CHANGE IN EXPRESSION WITHIN TARGET AND TREATMENT OVER TIME
overtime_comparison_function <-  function(list_object, return_var){
  norm_p_values <- do.call(rbind, lapply(split(list_object, list_object[,.(evaluation_weeks)]), function(subset){
    if(nrow(subset)>2){p_value <- shapiro.test(subset$norm_value)$p.value}
    else {p_value=0}
    return(p_value)}))
  
  homo_p_value <- fligner.test(list_object$norm_value, list_object$evaluation_weeks)$p.value 
  
  if(all(norm_p_values)>0.05){
      if(homo_p_value>0.05){
      aov_raw <-  aov(norm_value ~ evaluation_weeks, data = list_object)
      p_value <- summary(aov_raw)[[1]]$`Pr(>F)`[1]
    } else { 
      aov_welch_raw <- oneway.test(norm_value ~ evaluation_weeks, var.equal = FALSE, data = list_object)
      p_value <- as.numeric(aov_welch_raw[3])
    }
    } else {
      aov_raw <-  aov(norm_value ~ evaluation_weeks, data = list_object)
      p_value <- summary(aov_raw)[[1]]$`Pr(>F)`[1]
    }
  
  if(return_var=="multiple_group_p"){return(data.table(treatment=list_object[, treatment][1], variable = list_object[, variable][1], p_value = p_value))}
  if(return_var=="post_hoc_p"){}

}

overtime_comparison_p <- do.call(rbind, lapply(split(DT_melt, DT_melt[,.(variable, treatment)]), function(subset){overtime_comparison_function(subset, "multiple_group_p")}) )
#POST HOC TEST

#data.table(t(TukeyHSD(aov(norm_value ~ factor(evaluation_weeks), data = DT_melt[variable=="IL-1a"]))[[1]][,4]))

```

```{r echo=FALSE, warning=FALSE, error=FALSE, message=FALSE}
#Plotting individual targets
individual_target_plot <- function(target){
  plot_data <- DT_melt[variable==target]
  plot_data_summary <-  DT_summary[variable==target]
  p_value_data <-  group_comparison_p[variable==target]
  
  color_function <- function(week, pos_n){
    p_val <- p_value_data[, p_value][pos_n] 
    if(p_val<0.05){out_var="green"} else if (p_val<0.1 & p_val>0.05){out_var="orange"} else {out_var="red"}
    return(out_var)
  }
  
  color_function_overtime <- function(treat, target){
    p_val <-  overtime_comparison_p[treatment==treat & variable==target, p_value]
    if(p_val<0.05){out_var="green"} else if (p_val<0.1 & p_val>0.05){out_var="orange"} else {out_var="red"}
    return(out_var)
  }

  out_plot <- ggplot(plot_data_summary, aes(x=evaluation_weeks, y=norm_value, color=treatment))+
    #Main
    geom_segment(aes(x=1, xend=12, y=0, yend=0), color="black", size=1, linetype=2)+
    geom_errorbar(aes(ymin=CI.lower, ymax=CI.upper), size=3, width=1, position = position_dodge(width = 1), alpha=0.8, show.legend = FALSE)+
    geom_jitter(plot_data, mapping=aes(x=evaluation_weeks, y=norm_value, color=treatment), size=5, position = position_jitterdodge(jitter.width = 0.2, dodge.width = 1), alpha=0.7)+
    geom_point(shape = 15, size=8, position = position_dodge(width=1), show.legend = FALSE)+
    #Labels
    xlab("Weeks (Post SCI)")+
    ylab("log2(fold change)")+
    scale_x_continuous(breaks=seq(0,12,1))+
    scale_y_continuous(breaks=seq(-7,8,2), limits = c(-7, 12))+
    theme(axis.title = element_text(size=20, face="bold"), legend.position = "bottom", legend.justification = "center", legend.text = element_text(size=18), legend.title = element_blank(), axis.text = element_text(size=16), axis.line.y = element_blank())+
    #Colors
    scale_color_manual(values=brewer.pal(3, "Set1"), name="Treatment:", labels=c("SCI+NPC", "SCI+Saline"))+
    #Annotations
    annotate(geom="text", label=target, x=6.5, y=7.5, size=12, fontface=2, alpha=0.8)+
    
    annotate(geom="text",label=paste("", toString(format(p_value_data[, p_value][1], digits=2, nsmall = 2)), sep = ""), x=2, y=10, fontface=2, size=6, color=color_function(2, 1))+
    annotate(geom="text",label=paste("", toString(format(p_value_data[, p_value][2], digits=2, nsmall = 2)), sep = ""), x=5, y=10, fontface=2, size=6, color=color_function(5, 2))+
    annotate(geom="text",label=paste("", toString(format(p_value_data[, p_value][3], digits=2, nsmall = 2)), sep = ""), x=12, y=10, fontface=2, size=6, color=color_function(12, 3))+
    
    annotate(geom="text", label="NPC: ", x=5.5, y=-5.5, fontface=2, size=4)+
    annotate(geom="text", label=format(overtime_comparison_p[variable==target & treatment=="NPC", p_value], digits=2, scientific = TRUE), x=6.1, y=-5.5, fontface=2, size=4, color=color_function_overtime("NPC", target))+
    annotate(geom="text", label="Saline: ", x=6.8, y=-5.5, fontface=2, size=4)+
    annotate(geom="text", label=format(overtime_comparison_p[variable==target & treatment=="saline", p_value], digits=2, scientific = TRUE), x=7.5, y=-5.5, fontface=2, size=4, color=color_function_overtime("saline", target))+
    
    annotate(geom="text", label="UP-REGULATION", x=6.5, y=12, fontface=2, alpha=0.3, size=6)+
    annotate(geom="text", label="DOWN-REGULATION", x=6.5, y=-7, fontface=2, alpha=0.3, size=6)
  
  return(out_plot)  
}

```

```{r echo=FALSE, warning=FALSE, error=FALSE, message=FALSE}
#1. DEFINING INFLAMMATION TYPE FOR TARGETS
pro_inflammation <- data.table(variable=c("IL-1a", "IL-1b", "IL-5", "IL-6", "IL-12(p70)", "IL-17", "IL-18", "GM-CSF", "GRO/KC", "IFN-g", "MCP-1", "MIP-1a", "MIP-3a", "RANTES", "TNF-a"), inflammation_type="pro")
anti_inflammation <- data.table(variable=c("IL-4", "Il-10", "IL-13", "IL-2"), inflammation_type="anti")
variable_type <- rbind(pro_inflammation, anti_inflammation)
#2. MERGING RAW DATA SET WITH INFLAMMATION TYPE
DT_melt_inflammation <- merge(DT_melt, variable_type, by = "variable")
setkey(DT_melt_inflammation, inflammation_type)
#3. SUMMARIZING DATA FOR PLOTTING
DT_melt_inflammation_summary <- DT_melt_inflammation[, .(norm_value=mean(norm_value), norm_value_sd=sd(norm_value), n=.N), by=c("treatment", "evaluation_weeks", "inflammation_type")][,`:=`(SEMx1.96=qnorm(0.975)*norm_value_sd/sqrt(n))][,`:=`(CI.lower=norm_value-SEMx1.96, CI.upper=norm_value+SEMx1.96)]
setkey(DT_melt_inflammation_summary, inflammation_type, evaluation_weeks)
#STATISTICAL ANALYSIS
inflammation_intraday_p_value <- function(list_object, infl_type, counter){
  calc_data <- list_object[.(infl_type)]
  #Bootstrapping data
  calc_data <- do.call(rbind,lapply(split(calc_data, calc_data[, treatment]), function(subset){subset[sample(.N, nrow(subset), replace=TRUE)]}))
  #Evaluating assumptions
  norm_p_value <- do.call(rbind, lapply(split(calc_data, calc_data[, .(treatment)]), function(subset){data.table(treatment=subset$treatment, p_value=shapiro.test(subset$norm_value)$p.value)}))
  norm_p_value <- norm_p_value[, .(p_value=mean(p_value)), by="treatment"]
  
  homo_p_value <-  fligner.test(calc_data[,norm_value], calc_data[,treatment])$p.value

  if(isTRUE(norm_p_value[treatment=="NPC", p_value]>0.05)&isTRUE(norm_p_value[treatment=="saline", p_value]>0.05)){
    if(homo_p_value>0.05){
      p_value <- t.test(calc_data[treatment=="NPC", norm_value], calc_data[treatment=="saline", norm_value], var.equal = TRUE)$p.value
    } else {
      p_value <- t.test(calc_data[treatment=="NPC", norm_value], calc_data[treatment=="saline", norm_value], var.equal = FALSE)$p.value
    }
  } else {
    p_value <- wilcox.test(calc_data[treatment=="NPC", norm_value],calc_data[treatment=="saline", norm_value])$p.value
  }
  return(data.table(evaluation_weeks = calc_data[, evaluation_weeks][1], p_value = p_value))
}

inflammation_boot_p_values <- do.call(rbind, lapply(1:1000, function(nothing){do.call(rbind, lapply(split(DT_melt_inflammation, DT_melt_inflammation[,.(evaluation_weeks)]), function(subset){inflammation_intraday_p_value(subset, "pro", 1)}))}))

```


```{r echo=FALSE, warning=FALSE, error=FALSE, message=FALSE}
#4. INFLAMMATION OVER TIME PLOT FUNCTION
inflammation_overtime_plot <- function(infl_type){
  plot_data <- DT_melt_inflammation[.(infl_type)]
  plot_data_summary <- DT_melt_inflammation_summary[.(infl_type)]
  
  plot_out <- ggplot(plot_data_summary, aes(x=evaluation_weeks, y=norm_value, color=treatment))+
    geom_segment(aes(x=1, xend=12, y=0, yend=0), color="black", size=1, linetype=2)+
    geom_jitter(plot_data, mapping=aes(x=evaluation_weeks, y=norm_value, color=treatment), size=2, position = position_jitterdodge(jitter.width = 2, dodge.width = 2), alpha=0.7)+
    geom_errorbar(aes(ymin=CI.lower, ymax=CI.upper), position = position_dodge(width=2), size=3, width=1, show.legend = FALSE, alpha=0.8)+
    geom_smooth(plot_data, mapping=aes(x=evaluation_weeks, y=norm_value, color=treatment, fill=treatment), se=TRUE, alpha=0.2, show.legend = FALSE)+
    #Legends and shapes    
    xlab("Weeks (Post SCI)")+
    ylab("log2(fold change)")+
    scale_x_continuous(breaks=seq(0,12,1))+
    scale_y_continuous(breaks=seq(-3, 6, 1), limits = c(-4, 8))+
    theme(axis.title = element_text(size=20, face="bold"), legend.position = "bottom", legend.justification = "center", legend.text = element_text(size=18), legend.title = element_blank(), axis.text = element_text(size=16), axis.line.y = element_blank())+
    #Colors
    scale_color_manual(values=brewer.pal(3, "Set1"), name="Treatment:", labels=c("SCI+NPC", "SCI+Saline"))+
    scale_fill_manual(values=brewer.pal(3, "Set1"), name="Treatment:", labels=c("SCI+NPC", "SCI+Saline"))+
    #Annotations
    annotate(geom="text", label="UP-REGULATION", x=6.5, y=7, fontface=2, alpha=0.3, size=6)+
    annotate(geom="text", label="DOWN-REGULATION", x=6.5, y=-4, fontface=2, alpha=0.3, size=6)+
    
    annotate(geom="text", label=toString(format(inflammation_boot_p_values[evaluation_weeks==2, median(p_value)],digits=2, scientific = TRUE)), x=2, y=6, fontface=2, size=5, color="green")+
    annotate(geom="text", label=toString(format(inflammation_boot_p_values[evaluation_weeks==5, median(p_value)],digits=2, scientific = TRUE)), x=5, y=6, fontface=2, size=5, color="green")+
    annotate(geom="text", label=toString(format(inflammation_boot_p_values[evaluation_weeks==12, median(p_value)],digits=2, scientific = TRUE)), x=12, y=6, fontface=2, size=5, color="green")

  return(plot_out)
}

```

```{r echo=FALSE, warning=FALSE, error=FALSE, message=FALSE}
#HISTOGRAM OF BOOSTRAPPED P-VALUES FOR INDEPENDENT TWO GROUP COMPARISON
setkey(inflammation_boot_p_values, evaluation_weeks)

inflammation_boot_p_value_histo <- function(week){
  plot_data <- inflammation_boot_p_values[.(week)]
  plot_palette <- brewer.pal(9, "Blues")
  if(week==2){x_lower =-0.00001 ; x_upper=0.0005 ; plot_color=plot_palette[7]}
  if(week==5){x_lower=-0.001 ; x_upper=0.05 ; plot_color=plot_palette[8]}
  if(week==12){x_lower=-0.01 ; x_upper=1 ; plot_color=plot_palette[9]}
  
  plot_out <- ggplot(plot_data, aes(x=p_value))+
    geom_histogram(position="identity", fill=plot_color, alpha=0.9, bins=100)+
    xlim(x_lower, x_upper)+
    ylim(0,700)+
    theme(axis.title = element_blank(), axis.line.y = element_blank())+
    annotate(geom="text", label=paste(toString(week), "w"), x=x_upper/2, y=400, size=15)
  
  return(plot_out)
}

```

```{r echo=FALSE, warning=FALSE, error=FALSE, message=FALSE, fig.width=20, fig.height=20}
#1. HEATMAP OF CYTOKINES OVER TIME 
#For 2 & 5 w only and for all time points together
DT_heatmap <- DT_melt_inflammation[.("pro")][, .(norm_value_mean = mean(norm_value)), by=c("treatment", "variable", "evaluation_weeks")]
DT_heatmap <-  dcast.data.table(DT_heatmap, treatment+evaluation_weeks~variable, value.var="norm_value_mean")
DT_heatmap <- DT_heatmap[treatment=="saline", treatment:="Saline"]

#dev.off()
inflammation_heatmap_function <- function(week){
  heatmap_data_raw <- DT_heatmap[evaluation_weeks%in%week]

  col_names <- paste(paste(heatmap_data_raw[,treatment],"\n", heatmap_data_raw[,evaluation_weeks], sep=" "),"w", sep="")
  row_names <- names(heatmap_data_raw[,3:length(heatmap_data_raw)])
  heatmap_data <- heatmap_data_raw[, !c("treatment", "evaluation_weeks")]
  heatmap_data <- round(data.matrix(heatmap_data), digits=1)
  
  heatmap_out <- heatmap.2(heatmap_data,
                           dendrogram="column",
                           trace="none",
                           key=FALSE,
                           
                           cellnote=format(heatmap_data, digits=2), 
                           notecol="black",
                           notecex=2.5,
                           
                           col=bluered(100),
                           labRow = col_names,
                           cexRow = 3,
                           adjRow = c(0.1,0.5),
                           
                           cexCol = 3,
                           adjCol = c(1,0.5),
                           margins=c(16,10))

  invisible(heatmap_out)  
}
```


```{r echo=FALSE, warning=FALSE, error=FALSE, message=FALSE}
#1. CREATING DT_MELT WITH UNIQUE ANIMAL INDEX TO BE ABLE TO CALCULATE INFLAMMATION SUMMARY PROPERLY 
DT_mean <- DT[, !"SCI"]
DT_mean[,"index"] = 1:nrow(DT)
DT_mean <- melt.data.table(DT_mean, id.vars = c("index", "treatment", "evaluation_weeks"))
DT_mean <- do.call(rbind, lapply(split(DT_mean, DT_mean[,variable]), function(object){expression_normalizer(object)}))

DT_mean_summary <- DT_mean[, .(norm_value_mean=mean(norm_value)), by=c("index", "treatment", "evaluation_weeks")]

View(DT_mean_summary)



```



```{r echo=FALSE, warning=FALSE, error=FALSE, message=FALSE}
################################################################### OUTPUT ##############################################################
```
## Executive summary

*

*

***
\newpage

## Data modifications

* **Log2 fold change:** Fold change of expression was calculated for each day, animal and target by dividing the expression by the mean of the expression for the same target in healthy (none injured, none transplanted) animals. Log2 was taken of the fold change. Expression values equal to zero were set to 1 prior to fold change calculation in order to allow for log2() of fold change downstream.    

***

## Statistical analysis

###Evaluation of assumptions
* **Assumption of normality** was evaluated using *Shapiro Wilk's* test for each treatment (group) within each time point and for each target separately. Null hypothesis that data is normally distributed was rejected at the 5 % level.  

* **Assumption of homogenity** of variances was evaluated between the two treatments within each time point and for each target was evaluated using *Fligner Killeen's* test. Null hypothesis that the variances were equal was rejected at the 5 % level.   

###Independent intraday two group comparison
* **Two-sided non-paired Student's t-test** was used for group comparison given that data in both treatments was normally distributed and the variances were equal between the treatments. Given that data for both treatments was normally distributed but the groups had unequal variances the variance was estimated separately for each group and the Welch modification to the degrees of freedom was used. 

* **Two-sided non-paired Wilcoxon Rank Sum test** was used with continuity correction in the normal approximation for the p-value was used given that data in at least one of the treatments was not normally distributed. 

###Agglomerative hierarchical clustering

* Average expression for each cytokine/chemokine, week and treatment were clustered using agglomerative hierarchical clustering and presented with heatmap.  

### Independent multiple group within treatment comparison over time

* **One-way ANOVA** was used in case the data was normally distributed at all time points for a target and treatment, and the variances where homogenous between the treatments. In case the data was normally distributed but the variances were not homogenous the difference was assessed using **Welch ANOVA**. Assumptions of normality and homogenity of variances were evaluated as described above. One-way ANOVA was assumed to be robust against violations of the normality assumption.  

* **Tukey's post hoc test** was used for post hoc comparisons following one-way ANOVA. **Games-Howell test** was used for post hoc comparisons following Welch ANOVA.  

***
### Open source access
R-script and html-report can be accessed at [github](https://github.com/S-B-lab/SCI_NPC_multiplex). Please feel free to fork or make a pull request. 

***
\newpage

## Pro-inflammation over time
```{r echo=FALSE, warning=FALSE, error=FALSE, message=FALSE, fig.width=14, fig.height=7}
inflammation_overtime_plot("pro")

```

**Figure 1:** Figure log2(fold change in expression in relation to mean expresion in healthy control) of pro-inflammatory cytokines/chemokines (IL-1a, IL-1b, IL-5, IL-6, IL-12(p70), IL-17, IL-18, GM-CSF, GRO/KC, IFN-g, MCP-1, MIP-1a, MIP-3a, RANTES, TNF-a) over time for each treatment group. P-values for independent two group comparison is presented at each time point. P-values are median p-values of 1000 two-group comparisons of 1000 bootstrapped data samples for each treatment. Assumptions and test selection as described above.    

## Sensitivity analysis of comparison between treatments on pro-inflammation over time
```{r echo=FALSE, warning=FALSE, error=FALSE, message=FALSE, fig.width=14, fig.height=7}
grid.arrange(inflammation_boot_p_value_histo(2), inflammation_boot_p_value_histo(5), inflammation_boot_p_value_histo(12), ncol=3, bottom=textGrob("P-value", gp=gpar(fontsize=17, fontface="bold")), left=textGrob("Count (n)", gp=gpar(fontsize=17, fontface="bold"), rot=90))

```

**Figure 2:** Figure reports histograms (bins=100) of 1000 p-values for two group comparison calculated on bootstrapped data for pro-inflammation from each treatment at each time point. 

```{r echo=FALSE, warning=FALSE, error=FALSE, message=FALSE}
kable(format(dcast.data.table(inflammation_boot_p_values[, .(median_p_value=median(p_value)), by="evaluation_weeks"], ...~evaluation_weeks, value.var="median_p_value")[, 2:4], digits=2, scientific = TRUE), align="c", col.names=c("2w", "5w", "12w"))
```

**Table 1:** Median p-values of 1000 p-values for two group comparison calculted on bootstrapped data for pro-inflammation from each treatment at each time point. 

***
## Agglomerative hierarchical clustering 

### **2 weeks post SCI**
```{r echo=FALSE, warning=FALSE, error=FALSE, message=FALSE, fig.width=20, fig.height=10}
inflammation_heatmap_function(c(2))
```

### **5 weeks post SCI**
```{r echo=FALSE, warning=FALSE, error=FALSE, message=FALSE, fig.width=20, fig.height=10}
inflammation_heatmap_function(c(5))
```

### **12 weeks post SCI**
```{r echo=FALSE, warning=FALSE, error=FALSE, message=FALSE, fig.width=20, fig.height=10}
inflammation_heatmap_function(c(12))
```

### **2, 5 and 12 weeks** 
```{r echo=FALSE, warning=FALSE, error=FALSE, message=FALSE, fig.width=20, fig.height=15}
inflammation_heatmap_function(c(2,5,12))
```

**Figur 3:** Figure reports agglomerative hierarchical clustering with heatmap of pro-inflammatory cytokines/chemokines for each treatment and time point. Values are log2(fold change in expression in relation to mean expresion in healthy control).   

***
## Individual cytokines over time

```{r echo=FALSE, warning=FALSE, error=FALSE, message=FALSE, fig.width=20, fig.height=10}
#INDIVIDUAL CYTOKINES
plot_grid(individual_target_plot("IL-1a"), individual_target_plot("IL-1b"), individual_target_plot("IL-2"), individual_target_plot("IL-4"))
plot_grid(individual_target_plot("IL-6"), individual_target_plot("IL-10"), individual_target_plot("IL-12(p70)"), individual_target_plot("TNF-a"))
plot_grid(individual_target_plot("IL-13"), individual_target_plot("IL-17"), individual_target_plot("IL-18"), individual_target_plot("G-CSF"))
plot_grid(individual_target_plot("GM-CSF"), individual_target_plot("GRO/KC"), individual_target_plot("IFN-g"), individual_target_plot("M-CSF"))
plot_grid(individual_target_plot("MCP-1"), individual_target_plot("MIP-1a"), individual_target_plot("MIP-3a"), individual_target_plot("RANTES"))
plot_grid(individual_target_plot("VEGF"), individual_target_plot("IL-1a"), ncol=2, nrow=2)

```

**Figure 4:** Each plot reports log2(fold change in expression in relation to mean expresion in healthy control) of one cytokine. Statistical analysis as described above. P-values for comparison of the two independent groups are presented at each time point. Color of p-value is green if p-value < 0.05, orange if p-value>0.05 & p-value <0.1 and red if p-value >0.1. P-values for within treatment multiple comparison (over time) are presented in the lower part of the plot. 

```{r echo=FALSE, warning=FALSE, error=FALSE, message=FALSE}
#P-VALUES FOR INTRADAY COMPARISONS
p_table <- group_comparison_p
p_table[, "p_value"] <- p_table[, format(p_value, digits = 2)]
p_table[, "test"] = NULL
p_table <- dcast.data.table(p_table, ...~evaluation_week, value.var = "p_value")

#kable(p_table, align="c", col.names = c("Target", "P-value(2w)", "P-value(5w)", "P-value(12w)"))
```

\newpage

```{r echo=T, warning=F, message=F, error=F}
sessionInfo()
```
